Here's a complete Spring Boot application with proper exception handling to read and display approval configurations:

## 1. Project Structure

```
src/main/java/com/company/approval/
├── ApprovalApplication.java
├── config/
│   ├── JacksonConfig.java
│   └── GlobalExceptionHandler.java
├── controller/
│   └── ApprovalWorkflowController.java
├── service/
│   ├── ApprovalWorkflowService.java
│   └── impl/
│       └── ApprovalWorkflowServiceImpl.java
├── repository/
│   └── ApprovalWorkflowRepository.java
├── model/
│   ├── entity/
│   │   └── ApprovalWorkflowConfig.java
│   ├── dto/
│   │   ├── ApprovalRequest.java
│   │   ├── ApprovalResponse.java
│   │   ├── ApprovalHop.java
│   │   └── ErrorResponse.java
│   └── json/
│       ├── WorkflowConfig.java
│       ├── FieldOverride.java
│       ├── RangeCondition.java
│       └── ApproverHop.java
├── exception/
│   ├── ConfigurationNotFoundException.java
│   ├── InvalidFieldValueException.java
│   └── ApprovalServiceException.java
└── util/
    └── ApprovalEvaluator.java
```

## 2. Main Application Class

```java
package com.company.approval;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class ApprovalApplication {
    public static void main(String[] args) {
        SpringApplication.run(ApprovalApplication.class, args);
    }
}
```

## 3. Custom Exceptions

```java
package com.company.approval.exception;

public class ConfigurationNotFoundException extends RuntimeException {
    public ConfigurationNotFoundException(String message) {
        super(message);
    }
    
    public ConfigurationNotFoundException(String functionCode, String taskCode) {
        super(String.format("No approval configuration found for Function: %s, Task: %s", 
            functionCode, taskCode));
    }
}
```

```java
package com.company.approval.exception;

public class InvalidFieldValueException extends RuntimeException {
    public InvalidFieldValueException(String message) {
        super(message);
    }
    
    public InvalidFieldValueException(String fieldName, Object value) {
        super(String.format("Invalid value '%s' for field: %s", value, fieldName));
    }
}
```

```java
package com.company.approval.exception;

public class ApprovalServiceException extends RuntimeException {
    public ApprovalServiceException(String message) {
        super(message);
    }
    
    public ApprovalServiceException(String message, Throwable cause) {
        super(message, cause);
    }
}
```

## 4. Error Response DTO

```java
package com.company.approval.model.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ErrorResponse {
    private LocalDateTime timestamp;
    private int status;
    private String error;
    private String message;
    private String path;
    private String details;
}
```

## 5. Global Exception Handler

```java
package com.company.approval.config;

import com.company.approval.exception.ApprovalServiceException;
import com.company.approval.exception.ConfigurationNotFoundException;
import com.company.approval.exception.InvalidFieldValueException;
import com.company.approval.model.dto.ErrorResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.context.request.WebRequest;

import java.time.LocalDateTime;

@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(ConfigurationNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleConfigurationNotFound(
            ConfigurationNotFoundException ex, 
            WebRequest request) {
        
        log.error("Configuration not found: {}", ex.getMessage());
        
        ErrorResponse errorResponse = ErrorResponse.builder()
                .timestamp(LocalDateTime.now())
                .status(HttpStatus.NOT_FOUND.value())
                .error("Configuration Not Found")
                .message(ex.getMessage())
                .path(request.getDescription(false).replace("uri=", ""))
                .build();
        
        return new ResponseEntity<>(errorResponse, HttpStatus.NOT_FOUND);
    }

    @ExceptionHandler(InvalidFieldValueException.class)
    public ResponseEntity<ErrorResponse> handleInvalidFieldValue(
            InvalidFieldValueException ex, 
            WebRequest request) {
        
        log.error("Invalid field value: {}", ex.getMessage());
        
        ErrorResponse errorResponse = ErrorResponse.builder()
                .timestamp(LocalDateTime.now())
                .status(HttpStatus.BAD_REQUEST.value())
                .error("Invalid Field Value")
                .message(ex.getMessage())
                .path(request.getDescription(false).replace("uri=", ""))
                .build();
        
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    @ExceptionHandler(ApprovalServiceException.class)
    public ResponseEntity<ErrorResponse> handleApprovalServiceException(
            ApprovalServiceException ex, 
            WebRequest request) {
        
        log.error("Approval service exception: {}", ex.getMessage(), ex);
        
        ErrorResponse errorResponse = ErrorResponse.builder()
                .timestamp(LocalDateTime.now())
                .status(HttpStatus.INTERNAL_SERVER_ERROR.value())
                .error("Internal Server Error")
                .message(ex.getMessage())
                .path(request.getDescription(false).replace("uri=", ""))
                .details(ex.getCause() != null ? ex.getCause().getMessage() : null)
                .build();
        
        return new ResponseEntity<>(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR);
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidationException(
            MethodArgumentNotValidException ex, 
            WebRequest request) {
        
        log.error("Validation error: {}", ex.getMessage());
        
        String message = ex.getBindingResult().getFieldErrors().stream()
                .map(error -> error.getField() + ": " + error.getDefaultMessage())
                .findFirst()
                .orElse("Validation failed");
        
        ErrorResponse errorResponse = ErrorResponse.builder()
                .timestamp(LocalDateTime.now())
                .status(HttpStatus.BAD_REQUEST.value())
                .error("Validation Error")
                .message(message)
                .path(request.getDescription(false).replace("uri=", ""))
                .build();
        
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGlobalException(
            Exception ex, 
            WebRequest request) {
        
        log.error("Unexpected error occurred: {}", ex.getMessage(), ex);
        
        ErrorResponse errorResponse = ErrorResponse.builder()
                .timestamp(LocalDateTime.now())
                .status(HttpStatus.INTERNAL_SERVER_ERROR.value())
                .error("Internal Server Error")
                .message("An unexpected error occurred")
                .path(request.getDescription(false).replace("uri=", ""))
                .details(ex.getMessage())
                .build();
        
        return new ResponseEntity<>(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}
```

## 6. Jackson Configuration

```java
package com.company.approval.config;

import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.PropertyNamingStrategies;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class JacksonConfig {
    
    @Bean
    public ObjectMapper objectMapper() {
        ObjectMapper mapper = new ObjectMapper();
        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
        mapper.configure(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT, true);
        return mapper;
    }
}
```

## 7. Entity

```java
package com.company.approval.model.entity;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import javax.persistence.*;
import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "APPROVAL_WORKFLOW_CONFIG")
public class ApprovalWorkflowConfig {
    
    @Id
    @Column(name = "CONFIG_ID", length = 50)
    private String configId;
    
    @Column(name = "FUNCTION_CODE", length = 50, nullable = false)
    private String functionCode;
    
    @Column(name = "TASK_CODE", length = 50, nullable = false)
    private String taskCode;
    
    @Lob
    @Column(name = "CONFIG_JSON", nullable = false)
    private String configJson;
    
    @Column(name = "APPROVAL_TYPE", length = 20)
    private String approvalType;
    
    @Column(name = "IS_ACTIVE", length = 1)
    private String isActive;
    
    @Column(name = "CREATED_ON")
    private LocalDateTime createdOn;
    
    @Column(name = "CREATED_BY", length = 100)
    private String createdBy;
    
    @Column(name = "UPDATED_ON")
    private LocalDateTime updatedOn;
    
    @Column(name = "UPDATED_BY", length = 100)
    private String updatedBy;
}
```

## 8. DTOs

```java
package com.company.approval.model.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import javax.validation.constraints.NotBlank;
import java.util.Map;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ApprovalRequest {
    
    @NotBlank(message = "Function code is required")
    private String functionCode;
    
    @NotBlank(message = "Task code is required")
    private String taskCode;
    
    private Map<String, Object> fieldValues;
}
```

```java
package com.company.approval.model.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ApprovalResponse {
    private String configId;
    private String functionCode;
    private String taskCode;
    private String approvalType;
    private List<ApprovalHop> approvalHops;
    private String appliedRule;
    private boolean success;
    private String message;
}
```

```java
package com.company.approval.model.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ApprovalHop {
    private Integer sequence;
    private String hopName;
    private String approverGroupId;
    private String approverGroupName;
    private String isMandatory;
}
```

## 9. JSON Model Classes

```java
package com.company.approval.model.json;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;
import java.util.List;

@Data
public class WorkflowConfig {
    @JsonProperty("config_id")
    private String configId;
    
    @JsonProperty("function_code")
    private String functionCode;
    
    @JsonProperty("task_code")
    private String taskCode;
    
    @JsonProperty("base_approvers")
    private List<ApproverHop> baseApprovers;
    
    @JsonProperty("field_overrides")
    private List<FieldOverride> fieldOverrides;
}
```

```java
package com.company.approval.model.json;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

@Data
public class ApproverHop {
    @JsonProperty("seq")
    private Integer seq;
    
    @JsonProperty("group_id")
    private String groupId;
    
    @JsonProperty("group_name")
    private String groupName;
    
    @JsonProperty("is_mandatory")
    private String isMandatory;
}
```

```java
package com.company.approval.model.json;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;
import java.util.List;

@Data
public class FieldOverride {
    @JsonProperty("field")
    private String field;
    
    @JsonProperty("value")
    private String value;
    
    @JsonProperty("conditions")
    private List<RangeCondition> conditions;
    
    @JsonProperty("approvers")
    private List<ApproverHop> approvers;
}
```

```java
package com.company.approval.model.json;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;
import java.util.List;

@Data
public class RangeCondition {
    @JsonProperty("range")
    private Range range;
    
    @JsonProperty("approvers")
    private List<ApproverHop> approvers;
    
    @Data
    public static class Range {
        @JsonProperty("min")
        private Double min;
        
        @JsonProperty("max")
        private Double max;
        
        public boolean matches(Double value) {
            if (value == null) return false;
            
            boolean minMatch = (min == null || value >= min);
            boolean maxMatch = (max == null || value <= max);
            
            return minMatch && maxMatch;
        }
    }
}
```

## 10. Repository

```java
package com.company.approval.repository;

import com.company.approval.model.entity.ApprovalWorkflowConfig;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface ApprovalWorkflowRepository extends JpaRepository<ApprovalWorkflowConfig, String> {
    
    Optional<ApprovalWorkflowConfig> findByFunctionCodeAndTaskCodeAndIsActive(
        String functionCode, 
        String taskCode, 
        String isActive
    );
    
    List<ApprovalWorkflowConfig> findByIsActive(String isActive);
    
    @Query("SELECT a FROM ApprovalWorkflowConfig a WHERE " +
           "a.functionCode = :functionCode AND " +
           "a.isActive = 'Y'")
    List<ApprovalWorkflowConfig> findByFunctionCodeAndActive(
        @Param("functionCode") String functionCode
    );
}
```

## 11. Service Interface

```java
package com.company.approval.service;

import com.company.approval.model.dto.ApprovalRequest;
import com.company.approval.model.dto.ApprovalResponse;
import com.company.approval.model.entity.ApprovalWorkflowConfig;

import java.util.List;

public interface ApprovalWorkflowService {
    
    ApprovalResponse getApprovalHierarchy(ApprovalRequest request);
    
    List<ApprovalWorkflowConfig> getAllActiveConfigurations();
    
    ApprovalWorkflowConfig getConfigurationById(String configId);
}
```

## 12. Service Implementation

```java
package com.company.approval.service.impl;

import com.company.approval.exception.ApprovalServiceException;
import com.company.approval.exception.ConfigurationNotFoundException;
import com.company.approval.exception.InvalidFieldValueException;
import com.company.approval.model.dto.ApprovalHop;
import com.company.approval.model.dto.ApprovalRequest;
import com.company.approval.model.dto.ApprovalResponse;
import com.company.approval.model.entity.ApprovalWorkflowConfig;
import com.company.approval.model.json.ApproverHop;
import com.company.approval.model.json.FieldOverride;
import com.company.approval.model.json.RangeCondition;
import com.company.approval.model.json.WorkflowConfig;
import com.company.approval.repository.ApprovalWorkflowRepository;
import com.company.approval.service.ApprovalWorkflowService;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Slf4j
@Service
public class ApprovalWorkflowServiceImpl implements ApprovalWorkflowService {
    
    @Autowired
    private ApprovalWorkflowRepository repository;
    
    @Autowired
    private ObjectMapper objectMapper;
    
    @Override
    public ApprovalResponse getApprovalHierarchy(ApprovalRequest request) {
        
        log.info("Fetching approval hierarchy for Function: {}, Task: {}, Fields: {}", 
            request.getFunctionCode(), 
            request.getTaskCode(),
            request.getFieldValues() != null ? request.getFieldValues().keySet() : "None");
        
        try {
            // Validate input
            validateRequest(request);
            
            // Fetch configuration from database
            ApprovalWorkflowConfig config = fetchConfiguration(
                request.getFunctionCode(), 
                request.getTaskCode()
            );
            
            // Parse JSON configuration
            WorkflowConfig workflowConfig = parseConfiguration(config.getConfigJson());
            
            // Determine approval hops based on field values
            List<ApproverHop> approvers = determineApprovers(
                workflowConfig, 
                request.getFieldValues()
            );
            
            // Convert to response format
            List<ApprovalHop> approvalHops = convertToApprovalHops(approvers);
            
            // Build response
            ApprovalResponse response = ApprovalResponse.builder()
                .configId(config.getConfigId())
                .functionCode(config.getFunctionCode())
                .taskCode(config.getTaskCode())
                .approvalType(config.getApprovalType())
                .approvalHops(approvalHops)
                .success(true)
                .message("Approval hierarchy retrieved successfully")
                .build();
            
            log.info("Successfully retrieved {} approval hops for Config ID: {}", 
                approvalHops.size(), config.getConfigId());
            
            return response;
            
        } catch (ConfigurationNotFoundException | InvalidFieldValueException ex) {
            throw ex;
        } catch (Exception ex) {
            log.error("Unexpected error while fetching approval hierarchy", ex);
            throw new ApprovalServiceException(
                "Failed to retrieve approval hierarchy: " + ex.getMessage(), ex);
        }
    }
    
    @Override
    public List<ApprovalWorkflowConfig> getAllActiveConfigurations() {
        try {
            log.info("Fetching all active configurations");
            return repository.findByIsActive("Y");
        } catch (Exception ex) {
            log.error("Error fetching all configurations", ex);
            throw new ApprovalServiceException(
                "Failed to retrieve configurations", ex);
        }
    }
    
    @Override
    public ApprovalWorkflowConfig getConfigurationById(String configId) {
        try {
            log.info("Fetching configuration by ID: {}", configId);
            return repository.findById(configId)
                .orElseThrow(() -> new ConfigurationNotFoundException(
                    "Configuration not found with ID: " + configId));
        } catch (ConfigurationNotFoundException ex) {
            throw ex;
        } catch (Exception ex) {
            log.error("Error fetching configuration by ID: {}", configId, ex);
            throw new ApprovalServiceException(
                "Failed to retrieve configuration", ex);
        }
    }
    
    private void validateRequest(ApprovalRequest request) {
        if (!StringUtils.hasText(request.getFunctionCode())) {
            throw new InvalidFieldValueException("Function code cannot be empty");
        }
        if (!StringUtils.hasText(request.getTaskCode())) {
            throw new InvalidFieldValueException("Task code cannot be empty");
        }
    }
    
    private ApprovalWorkflowConfig fetchConfiguration(String functionCode, String taskCode) {
        return repository.findByFunctionCodeAndTaskCodeAndIsActive(functionCode, taskCode, "Y")
            .orElseThrow(() -> new ConfigurationNotFoundException(functionCode, taskCode));
    }
    
    private WorkflowConfig parseConfiguration(String configJson) {
        try {
            return objectMapper.readValue(configJson, WorkflowConfig.class);
        } catch (JsonProcessingException ex) {
            log.error("Failed to parse configuration JSON", ex);
            throw new ApprovalServiceException(
                "Invalid configuration format in database", ex);
        }
    }
    
    private List<ApproverHop> determineApprovers(
        WorkflowConfig config, 
        Map<String, Object> fieldValues
    ) {
        
        // If no field values provided, return base approvers
        if (fieldValues == null || fieldValues.isEmpty()) {
            log.info("No field values provided, returning base approvers");
            return getBaseApprovers(config);
        }
        
        // Check field overrides
        if (config.getFieldOverrides() != null && !config.getFieldOverrides().isEmpty()) {
            
            for (FieldOverride override : config.getFieldOverrides()) {
                String fieldCode = override.getField();
                
                if (!fieldValues.containsKey(fieldCode)) {
                    log.debug("Field {} not present in request, skipping override", fieldCode);
                    continue;
                }
                
                Object fieldValue = fieldValues.get(fieldCode);
                
                // Check for exact value match
                if (StringUtils.hasText(override.getValue())) {
                    if (matchesExactValue(fieldValue, override.getValue())) {
                        log.info("Matched exact value override: {}={}", fieldCode, fieldValue);
                        return override.getApprovers();
                    }
                }
                
                // Check for range conditions
                if (override.getConditions() != null && !override.getConditions().isEmpty()) {
                    List<ApproverHop> matchedApprovers = evaluateRangeConditions(
                        fieldCode, 
                        fieldValue, 
                        override.getConditions()
                    );
                    if (matchedApprovers != null) {
                        return matchedApprovers;
                    }
                }
            }
        }
        
        // Return base approvers if no overrides matched
        log.info("No field overrides matched, returning base approvers");
        return getBaseApprovers(config);
    }
    
    private boolean matchesExactValue(Object fieldValue, String expectedValue) {
        return fieldValue != null && fieldValue.toString().equalsIgnoreCase(expectedValue);
    }
    
    private List<ApproverHop> evaluateRangeConditions(
        String fieldCode, 
        Object fieldValue, 
        List<RangeCondition> conditions
    ) {
        
        try {
            Double numericValue = parseNumericValue(fieldValue);
            
            for (RangeCondition condition : conditions) {
                if (condition.getRange().matches(numericValue)) {
                    log.info("Matched range condition for {}={} (range: min={}, max={})", 
                        fieldCode, 
                        numericValue,
                        condition.getRange().getMin(),
                        condition.getRange().getMax());
                    return condition.getApprovers();
                }
            }
        } catch (NumberFormatException ex) {
            log.warn("Could not parse field value as number for field {}: {}", 
                fieldCode, fieldValue);
        }
        
        return null;
    }
    
    private Double parseNumericValue(Object value) throws NumberFormatException {
        if (value == null) {
            throw new NumberFormatException("Value is null");
        }
        
        if (value instanceof Number) {
            return ((Number) value).doubleValue();
        }
        
        return Double.parseDouble(value.toString());
    }
    
    private List<ApproverHop> getBaseApprovers(WorkflowConfig config) {
        if (config.getBaseApprovers() != null && !config.getBaseApprovers().isEmpty()) {
            return config.getBaseApprovers();
        }
        
        log.warn("No base approvers defined in configuration");
        return new ArrayList<>();
    }
    
    private List<ApprovalHop> convertToApprovalHops(List<ApproverHop> approvers) {
        return approvers.stream()
            .map(this::convertToApprovalHop)
            .collect(Collectors.toList());
    }
    
    private ApprovalHop convertToApprovalHop(ApproverHop approver) {
        return ApprovalHop.builder()
            .sequence(approver.getSeq())
            .approverGroupId(approver.getGroupId())
            .approverGroupName(approver.getGroupName())
            .isMandatory(approver.getIsMandatory())
            .build();
    }
}
```

## 13. Controller

```java
package com.company.approval.controller;

import com.company.approval.model.dto.ApprovalRequest;
import com.company.approval.model.dto.ApprovalResponse;
import com.company.approval.model.entity.ApprovalWorkflowConfig;
import com.company.approval.service.ApprovalWorkflowService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import javax.validation.Valid;
import java.util.List;

@Slf4j
@RestController
@RequestMapping("/api/approval")
@CrossOrigin(origins = "*")
public class ApprovalWorkflowController {
    
    @Autowired
    private ApprovalWorkflowService approvalWorkflowService;
    
    /**
     * Get approval hierarchy based on function, task and optional field values
     * 
     * POST /api/approval/hierarchy
     * 
     * Request Body:
     * {
     *   "functionCode": "SENDER_AUTH",
     *   "taskCode": "ADD",
     *   "fieldValues": {
     *     "PROCESS_TYPE": "ACH_DEBIT_BLOCKING"
     *   }
     * }
     */
    @PostMapping("/hierarchy")
    public ResponseEntity<ApprovalResponse> getApprovalHierarchy(
        @Valid @RequestBody ApprovalRequest request
    ) {
        log.info("POST /api/approval/hierarchy - Function: {}, Task: {}", 
            request.getFunctionCode(), request.getTaskCode());
        
        ApprovalResponse response = approvalWorkflowService.getApprovalHierarchy(request);
        
        return ResponseEntity.ok(response);
    }
    
    /**
     * Get approval hierarchy using query parameters (without field values)
     * 
     * GET /api/approval/hierarchy?functionCode=SENDER_AUTH&taskCode=ADD
     */
    @GetMapping("/hierarchy")
    public ResponseEntity<ApprovalResponse> getApprovalHierarchySimple(
        @RequestParam(required = true) String functionCode,
        @RequestParam(required = true) String taskCode
    ) {
        log.info("GET /api/approval/hierarchy - Function: {}, Task: {}", 
            functionCode, taskCode);
        
        ApprovalRequest request = ApprovalRequest.builder()
            .functionCode(functionCode)
            .taskCode(taskCode)
            .build();
        
        ApprovalResponse response = approvalWorkflowService.getApprovalHierarchy(request);
        
        return ResponseEntity.ok(response);
    }
    
    /**
     * Get all active approval configurations
     * 
     * GET /api/approval/configurations
     */
    @GetMapping("/configurations")
    public ResponseEntity<List<ApprovalWorkflowConfig>> getAllConfigurations() {
        log.info("GET /api/approval/configurations");
        
        List<ApprovalWorkflowConfig> configurations = 
            approvalWorkflowService.getAllActiveConfigurations();
        
        return ResponseEntity.ok(configurations);
    }
    
    /**
     * Get specific configuration by ID
     * 
     * GET /api/approval/configurations/{configId}
     */
    @GetMapping("/configurations/{configId}")
    public ResponseEntity<ApprovalWorkflowConfig> getConfigurationById(
        @PathVariable String configId
    ) {
        log.info("GET /api/approval/configurations/{}", configId);
        
        ApprovalWorkflowConfig config = 
            approvalWorkflowService.getConfigurationById(configId);
        
        return ResponseEntity.ok(config);
    }
    
    /**
     * Health check endpoint
     */
    @GetMapping("/health")
    public ResponseEntity<String> health() {
        return ResponseEntity.ok("Approval Workflow Service is running");
    }
}
```

## 14. Application Configuration

```yaml
# application.yml
server:
  port: 8080
  servlet:
    context-path: /

spring:
  application:
    name: approval-workflow-service
  
  datasource:
    url: jdbc:oracle:thin:@localhost:1521:ORCL
    username: your_username
    password: your_password
    driver-class-name: oracle.jdbc.OracleDriver
    hikari:
      maximum-pool-size: 10
      minimum-idle: 5
      connection-timeout: 30000
      idle-timeout: 600000
      max-lifetime: 1800000
  
  jpa:
    hibernate:
      ddl-auto: none
      naming:
        physical-strategy: org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl
    show-sql: false
    properties:
      hibernate:
        format_sql: true
        dialect: org.hibernate.dialect.Oracle12cDialect
        jdbc:
          lob:
            non_contextual_creation: true

logging:
  level:
    com.company.approval: DEBUG
    org.hibernate.SQL: DEBUG
    org.hibernate.type.descriptor.sql.BasicBinder: TRACE
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} - %msg%n"
```

## 15. Maven Dependencies (pom.xml)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www